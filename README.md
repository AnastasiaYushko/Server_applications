# Задание 1. Разработка эмулятора сервера
Постановка задачи. Необходимо реализовать приложение учета посещаемости занятий
студентами.
Требования к реализации. Система должна:

1 - Хранить списки студентов, групп студентов, преподавателей с возможностью
добавить новый объект, отредактировать существующий, удалить объект получить
объект по идентификатору, получить список всех объектов.

2 - Хранить список дисциплин с аналогичными возможностями.

3- Преподаватель должен иметь возможность создать в системе занятие, указав для
него дисциплину, группу студентов (или несколько групп), для которых занятие
проводилось, дату занятия и время (номер пары).

4 - Предполагается, что созданные занятия можно будет редактировать / удалять,
получать список занятий за указанный промежуток дат.

5 - Предполагается, что на занятии должны присутствовать все студенты всех групп,
которые были указаны при создании занятия. Преподаватель должен иметь
возможность указать, кто из студентов фактически присутствовал на занятии (с
возможностью исправления ошибочных данных).
Замечание. Упрощаем реальную жизнь:
1) считаем, что на каждое занятие ходит только одна группа студентов,
2) считаем, что количество сущностей любого вида небольшое, и мы можем получить
список всех объектов из базы данных одним запросом, хранить такой список в
памяти и передавать по сети разом,
3) мы не умеем работать с сетью и базами данных, поэтому вместо этого будут
заглушки.
Основные сущности
1) «Группа студентов»: хранит название группы.
2) «Студент»: хранит ФИО студента (по отдельности), статус студента (учится, в а/о,
отчислен), группу.
3) «Преподаватель»: ФИО преподавателя.
4) «Дисциплина»: название дисциплины.
5) «Занятие»: дата проведения, время проведения (номер пары), преподаватель, группу.
6) «Посещение занятия»: занятие, список студентов, которые были на занятии.
Предполагается, что сущности будут храниться в базе данных, поэтому каждый объект в
базе будет иметь уникальный целочисленный идентификатор (id).
Запросы к серверу (API сервера)
Запрос к серверу осуществляется на URL вида
http(s)://<server_domain>/<path>/<endpoint>,
например, https://student-log.ru/api/getStudents.
Вместе с запросов передаются необходимые ему данные в виде json-строки.
/*
Протокол HTTP имеет несколько методов запросов (GET, POST и т.д.), в зависимости от
метода данные запроса могут передаваться разных местах (в теле запроса, в
параметрах, в пути). У нас ситуация упрощенная: все передаем в теле запроса.

### Этапы решения
1. Написать классы для представления данных запросов (AddStudentRequest,
GetStudentRequest, EditTeacherRequest и т.д.). Для одной и той же сущности может быть
несколько классов-запросов в зависимости от смысла запроса.
2. Написать набор валидаторов данных запросов.
а) Написать набор валидаторов примитивных сущностей (чисел, строк определенного
вида, дат и т.д.). Например, валидатор id должен проверять, что это число
положительное, валидатор строки проверяет, что строка существует (не null), непустая, и
ее длина не больше определенного максимума, валидатор дат проверяет соответствие
строки с датой регулярному выражению.
б) Написать интерфейс валидатора запроса с методом, который получает на вход запрос
(объект произвольного класса) и возвращает список ошибок (список строк).
в) Для классов-запросов написать их классы-валидаторы. Эти валидаторы проверяют
корректность полей с помощью валидаторов примитивных сущностей, складывая ошибки
в список-результат.
/*
Фреймворки разработки серверных приложений часто имеют встроенные средства
валидации. Например, Spring Validation позволяет валидировать запрос простым
навешиванием аннотаций на его поля.
*/
3. Напишите классы для представления данных в ответах (EditStudentResponse,
GetTeachesResponse и т.д.). Ответ должен содержать данные, которые клиент сможет
показать на экране, причем минимальный набор таких данных.
Например, ответ на запрос на получение студента должен хранить: ФИО студента, его
статус и название группы. Ответ на запрос /getLessonById должен содержать дату
проведения занятия, номер пары, название группы, ФИО преподавателя, название
предмета и список студентов группы с отметками о посещении.
4. Написать следующий набор классов для внутреннего представления сущностей (для
работы с БД). Каждый класс включает в себя поле id — уникальный целочисленный
идентификатор (может обращаться в null), конструктор по значениям всех полей, геттеры,
equals и hashCode.
5. Написать набор интерфейсов репозиториев (хранилищ данных) для сущностей из п.1.
Каждый репозиторий предоставляет набор методов (возможны дополнительные
методы):
добавление сущности в репозиторий (на входе сущность с id = null, сущность добавляется
в хранилище, при этом ей назначается значение id, этот id возвращается как результат),
редактирование существующей сущности (на входе сущность с непустым id, входная
сущность подменяет старую),
- удаление сущности по id,
- получение сущности по id,
- получение всех сущностей.
Замечание. Считаем, что все наборы сущностей небольшие и могут быть извлечены из
хранилища целиком за раз.
1) Репозитории групп студентов, студентов, преподавателей, дисциплин не содержат
методов, кроме перечисленных.
2) Репозиторий занятий вместо метода получения всех занятий содержит:
- получение всех занятий по id преподавателя за заданный промежуток дат,
-  получение всех занятий по id группы за заданный промежуток дат,
-  даление всех занятий по id преподавателя,
-  удаление всех занятий по id группы.
Репозиторий занятий не работает с данными о посещаемости.
4) Репозиторий посещаемости содержит методы:
-  добавить данные о посещаемости для занятия по id занятия,
-  удалить данные о посещаемости по id занятия.
6. Напишите классы-заглушки для репозиториев (методы get* возвращают конкретные
объекты, создаваемые на месте), методы add/edit/delete не делают ничего (пишут
сообщение на консоль).
7. Для сущностей «Группа студентов» и «Студент» напишите классы-контроллеры,
отвечающие за сетевые операции.
Контроллер содержит методы, соответствующие методам API. Метод контроллера
получает на вход объект-запрос, валидирует его и вызывает сервис по его обработке
(пока сервиса нет, оставьте заглушку или комментарий).
Сервер вместе с данными ответа должен возвращать служебную информацию,
необходимую протоколу HTTP, в частности, HTTP-статус (погуглите про это).

а) Напишите сущность-обертку ResponseEntity<T>, которая хранит данные ответа и статус.
/*
Фреймворки разработки серверных приложений обычно предоставляют готовую
обертку
*/

б) Напишите контроллеры с методами вида
ResponseEntity<StudentResponse> getStudentById(GetStudentByIdRequest request) { … }
/*
Как правило, клиенту недостаточно HTTP-статусов, т.к. возможных ошибок много
больше, чем подходящих статусов. Мы решим эту проблему позже.
*/

8. Для сущностей «Студент» и «Группа студентов» напишите интерфейсы сервисов,
которые необходимы в контроллерах.
9. Добавьте обработку исключений на всех уровнях.
- Все репозитории должны отлавливать исключения от СУБД и транслировать их в
RepositoryException.
- Сервисы должны отлавливать RepositoryException и, возможно, какие-то свои
исключения и транслировать в ServiceException. Возможны производные
исключения. Например, метод сервиса get*ById в случае отсутствия в базе
сущности с заданным id выбрасывает производное исключение NotFoundException.
 Контроллеры должны перехватывать в конечном счете все исключения, т.к.
недопустимо появление на стороне клиента ошибок со статусами 50x. В случае
успеха контроллер устанавливает статус OK (200), в случае ошибок – NOT_FOUND
(404), UNPROCESSIBLE_ENTITY (422).
